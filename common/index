#!/bin/sh
. "$GITTEMPLATE_DIR/common/defs"

checkTemplateExist() {
	if [ ! -d "$DEFINE_TEMPLATE_ROOTPATH" ]; then
		echo "No Template found"
		echo ""
		echo "to add one use: 'git template add' or 'git template init'"
		exit 1
	fi
}

checkTemplateNotExist() {
	# multiple template is not supported
	if [ -d "$DEFINE_TEMPLATE_ROOTPATH" ]; then
		echo "Template ($DEFINE_TEMPLATE_ROOTPATH) already defined"
		echo ""
		echo "to remove it use: 'git template remove'"
		exit 1
	fi
}

isLocked() {
	# if .template/tree not available then we assume
	# that template is locked
	if [ ! -d "$DEFINE_TEMPLATE_GITPATH" ]; then
		return 0
	fi
	return 1
}

#make it ready for project container commit
lockTemplate() {
	if isLocked; then 
		#echo Template already lock
		return
	fi
	# check git status
	rm -rf "$DEFINE_TEMPLATE_TMP"
	cd "$DEFINE_TEMPLATE_GITPATH"
	local status=$(git status --porcelain)
	if [ ! -z "$status" ]; then
		echo
		printf $RED"Couldn\'t lock template\n"$CLEAR
		echo
		git status
		exit 1 
	fi 
	# update current SHA (can be branch, tag, or raw SHA)
	local sha=$(git symbolic-ref -q --short HEAD || git describe --tags --exact-match 2>/dev/null || git rev-parse HEAD)
	perl "$GITTEMPLATE_DIR/common/config.pl" core.sha $sha
	git checkout --orphan empty >/dev/null 2>&1
	git reset >/dev/null 2>&1
	_lock
}

unlockTemplate() {
	if ! isLocked; then 
		#echo Template already unlock
		return
	fi
	_unlock
	rm -rf "$DEFINE_TEMPLATE_TMP"
	# checks git satus
	git status>/dev/null 2>&1 
	if [ $? != 0 ]; then
		printf $RED"Couldn\'t unlock template\n"
		printf "Invalid template\n"$CLEAR
		_lock
		exit 1
	fi
	# get SHA
	SHA=$(perl "$GITTEMPLATE_DIR/common/config.pl" core.sha);
	if [ -z "$SHA" ]; then 
		printf $RED"Couldn\'t unlock template\n"
		printf "Invalid SHA\n"$CLEAR
		_lock
		exit 1
	fi
	git checkout $SHA >/dev/null 2>&1
	if [ $? != 0 ]; then
		printf $RED"Couldn\'t unlock template\n"
		printf "checkout $SHA failed\n"$CLEAR
		_lock
		exit 1
	fi
	mkdir -p "$DEFINE_TEMPLATE_CONTENT"
}

delete() {
	# remove template folder
	git rm -rf "$DEFINE_TEMPLATE_ROOTPATH" >/dev/null 2>&1

	# unfortunatly 'git rm -rf' is not enough
	if true; then
		# remove submodule in .git/config
		git config -f .git/config --remove-section submodule.$DEFINE_TEMPLATE_GITPATH >/dev/null 2>&1
		# remove submodule in .git/modules
		rm -rf .git/modules/$DEFINE_TEMPLATE_ROOT >/dev/null 2>&1 
		# remove submodule in .gitmodules
		git config -f .gitmodules --remove-section submodule.$DEFINE_TEMPLATE_GITPATH >/dev/null 2>&1 
		# if .gitmodules is empty delete it
		[ ! -s .gitmodules ] && rm -f .gitmodules >/dev/null 2>&1 	
	fi

	# remove 
	rm -r "$DEFINE_TEMPLATE_ROOTPATH" >/dev/null 2>&1 

	# clean up cached files/folders if needed
	git status --porcelain | sed -n 's/^.D \(\.template\/.*\)$/\1/p' | xargs -I {} git rm --cached {}
	git status --porcelain | grep -q "^.D .gitmodules$" && git rm --cached .gitmodules
}

addTemplate() {
	local branch=$1;
	local repo=$2;
	mkdir -p $DEFINE_TEMPLATE_ROOTPATH
	git submodule add -b $branch $repo $DEFINE_TEMPLATE_GITPATH
	if [ ! -e "$DEFINE_TEMPLATE_GITPATH" ]; then
		echo "Error couldn't add '$repo'"
		delete
		exit 1
	fi
	mkdir -p $DEFINE_TEMPLATE_OBJECTPATH
	touch $DEFINE_TEMPLATE_INSTANCE_CONFIG
}

yesNoPrompt() {
	[[ -t 0 ]] && read -e -n 1 -p "(Y/n)" res
	if [[ $res =~ ^(y|Y)$ ]]
	then
		return 0 # err=0 mean success
	else
		return 1
	fi
}